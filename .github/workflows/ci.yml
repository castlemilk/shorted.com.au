name: Preview and Test

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, edited]
  pull_request_target:
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:

env:
  NODE_VERSION: "20"
  GO_VERSION: "1.23"
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: australia-southeast2
  ARTIFACT_REGISTRY: australia-southeast2-docker.pkg.dev
  PR_NUMBER: ${{ github.event.pull_request.number || 'manual' }}

permissions:
  contents: read
  id-token: write
  pull-requests: write
  deployments: write

jobs:
  check-secrets:
    runs-on: ubuntu-latest
    outputs:
      has-gcp: ${{ steps.check.outputs.has-gcp }}
    steps:
      - name: Check required secrets
        id: check
        run: |
          HAS_GCP="false"
          if [ -n "${{ secrets.GCP_PROJECT_ID }}" ] && [ -n "${{ secrets.WIP_PROVIDER }}" ] && [ -n "${{ secrets.SA_EMAIL }}" ]; then
            HAS_GCP="true"
          fi
          echo "has-gcp=$HAS_GCP" >> $GITHUB_OUTPUT
          echo "GCP secrets configured: $HAS_GCP"

  deploy-backend:
    needs: check-secrets
    if: needs.check-secrets.outputs.has-gcp == 'true' && github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork == false
    runs-on: ubuntu-latest
    outputs:
      shorts-url: ${{ steps.deploy-services.outputs.shorts-url }}
      market-data-url: ${{ steps.deploy-services.outputs.market-data-url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: web/package-lock.json

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: services/go.sum

      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIP_PROVIDER }}
          service_account: ${{ secrets.SA_EMAIL }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker ${{ env.ARTIFACT_REGISTRY }}

      - name: Build and push Docker images
        run: |
          cd services

          # Build and push Shorts Service
          docker build -f shorts/Dockerfile -t ${{ env.ARTIFACT_REGISTRY }}/${{ env.GCP_PROJECT_ID }}/shorted/shorts:pr-${{ env.PR_NUMBER }} .
          docker push ${{ env.ARTIFACT_REGISTRY }}/${{ env.GCP_PROJECT_ID }}/shorted/shorts:pr-${{ env.PR_NUMBER }}

          # Build and push Market Data Service
          docker build -f market-data/Dockerfile -t ${{ env.ARTIFACT_REGISTRY }}/${{ env.GCP_PROJECT_ID }}/shorted/market-data:pr-${{ env.PR_NUMBER }} market-data/
          docker push ${{ env.ARTIFACT_REGISTRY }}/${{ env.GCP_PROJECT_ID }}/shorted/market-data:pr-${{ env.PR_NUMBER }}

      - name: Deploy preview backend services to Cloud Run
        id: deploy-services
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: |
          # Parse DATABASE_URL to extract components
          DB_USER=$(echo $DATABASE_URL | sed -n 's|postgresql://\([^:]*\):.*|\1|p')
          DB_PASS=$(echo $DATABASE_URL | sed -n 's|postgresql://[^:]*:\([^@]*\)@.*|\1|p')
          DB_HOST=$(echo $DATABASE_URL | sed -n 's|.*@\([^:]*\):.*|\1|p')
          DB_PORT=$(echo $DATABASE_URL | sed -n 's|.*:\([0-9]*\)/.*|\1|p')
          DB_NAME=$(echo $DATABASE_URL | sed -n 's|.*/\([^?]*\).*|\1|p')
          DB_ADDRESS="${DB_HOST}:${DB_PORT}"

          echo "Deploying with database: $DB_ADDRESS (database: $DB_NAME)"

          # Deploy Shorts Service
          gcloud run deploy shorts-service-pr-${{ env.PR_NUMBER }} \
            --image ${{ env.ARTIFACT_REGISTRY }}/${{ env.GCP_PROJECT_ID }}/shorted/shorts:pr-${{ env.PR_NUMBER }} \
            --region ${{ env.GCP_REGION }} \
            --platform managed \
            --allow-unauthenticated \
            --port 9091 \
            --memory 256Mi \
            --cpu 1 \
            --min-instances 0 \
            --max-instances 2 \
            --set-env-vars="APP_STORE_POSTGRES_ADDRESS=$DB_ADDRESS" \
            --set-env-vars="APP_STORE_POSTGRES_USERNAME=$DB_USER" \
            --set-env-vars="APP_STORE_POSTGRES_PASSWORD=$DB_PASS" \
            --set-env-vars="APP_STORE_POSTGRES_DATABASE=$DB_NAME" \
            --set-env-vars="ENVIRONMENT=preview" \
            --labels="pr=${{ env.PR_NUMBER }},type=preview" \
            --tag pr-${{ env.PR_NUMBER }}

          # Deploy Market Data Service
          gcloud run deploy market-data-service-pr-${{ env.PR_NUMBER }} \
            --image ${{ env.ARTIFACT_REGISTRY }}/${{ env.GCP_PROJECT_ID }}/shorted/market-data:pr-${{ env.PR_NUMBER }} \
            --region ${{ env.GCP_REGION }} \
            --platform managed \
            --allow-unauthenticated \
            --port 8090 \
            --memory 256Mi \
            --cpu 1 \
            --min-instances 0 \
            --max-instances 2 \
            --set-env-vars="DATABASE_URL=$DATABASE_URL" \
            --set-env-vars="APP_STORE_POSTGRES_ADDRESS=$DB_ADDRESS" \
            --set-env-vars="APP_STORE_POSTGRES_USERNAME=$DB_USER" \
            --set-env-vars="APP_STORE_POSTGRES_PASSWORD=$DB_PASS" \
            --set-env-vars="APP_STORE_POSTGRES_DATABASE=$DB_NAME" \
            --set-env-vars="ENVIRONMENT=preview" \
            --labels="pr=${{ env.PR_NUMBER }},type=preview" \
            --tag pr-${{ env.PR_NUMBER }}

          # Get service URLs
          SHORTS_URL=$(gcloud run services describe shorts-service-pr-${{ env.PR_NUMBER }} \
            --region ${{ env.GCP_REGION }} --format 'value(status.url)')
          MARKET_DATA_URL=$(gcloud run services describe market-data-service-pr-${{ env.PR_NUMBER }} \
            --region ${{ env.GCP_REGION }} --format 'value(status.url)')

          echo "shorts-url=$SHORTS_URL" >> $GITHUB_OUTPUT
          echo "market-data-url=$MARKET_DATA_URL" >> $GITHUB_OUTPUT
          echo "Shorts Service: $SHORTS_URL"
          echo "Market Data Service: $MARKET_DATA_URL"

      - name: Summary
        run: |
          echo "âœ… Backend services deployed successfully for PR #${{ env.PR_NUMBER }}"
          echo "Shorts Service: ${{ steps.deploy-services.outputs.shorts-url }}"
          echo "Market Data Service: ${{ steps.deploy-services.outputs.market-data-url }}"

  deploy-vercel-preview:
    needs: [check-secrets, deploy-backend]
    runs-on: ubuntu-latest
    if: needs.check-secrets.outputs.has-gcp == 'true' && needs.deploy-backend.outputs.shorts-url != ''
    environment:
      name: preview
      url: ${{ steps.deploy.outputs.url }}
    outputs:
      preview-url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 0
          persist-credentials: false

      - name: Deploy to Vercel
        id: deploy
        uses: amondnet/vercel-action@v25
        env:
          VERCEL_ENV: dev
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: team_xE5DMN3hIo8aPqyHNkBybg8r
          vercel-project-id: shorted-com-au
          scope: team_xE5DMN3hIo8aPqyHNkBybg8r
          alias-domains: preview.shorted.com.au
          vercel-args: >-
            --build-env NEXT_PUBLIC_SHORTS_SERVICE_ENDPOINT=${{ needs.deploy-backend.outputs.shorts-url }}
            --build-env NEXT_PUBLIC_MARKET_DATA_API_URL=${{ needs.deploy-backend.outputs.market-data-url }}
            --build-env AUTH_GOOGLE_ID=${{ secrets.AUTH_GOOGLE_ID }}
            --build-env AUTH_GOOGLE_SECRET=${{ secrets.AUTH_GOOGLE_SECRET }}
            --env NEXT_PUBLIC_SHORTS_SERVICE_ENDPOINT=${{ needs.deploy-backend.outputs.shorts-url }}
            --env NEXT_PUBLIC_MARKET_DATA_API_URL=${{ needs.deploy-backend.outputs.market-data-url }}
            --env AUTH_GOOGLE_ID=${{ secrets.AUTH_GOOGLE_ID }}
            --env AUTH_GOOGLE_SECRET=${{ secrets.AUTH_GOOGLE_SECRET }}
            --env NEXTAUTH_URL=https://preview.shorted.com.au

      - name: Summary
        run: |
          echo "âœ… Frontend deployed to Vercel: ${{ steps.deploy.outputs.url }}"
          echo "Connected to Shorts API: ${{ needs.deploy-backend.outputs.shorts-url }}"
          echo "Connected to Market Data API: ${{ needs.deploy-backend.outputs.market-data-url }}"

  comment-deployment:
    needs: [check-secrets, deploy-backend, deploy-vercel-preview]
    runs-on: ubuntu-latest
    if: always() && github.event_name == 'pull_request'
    steps:
      - name: Comment PR with deployment info
        uses: actions/github-script@v7
        with:
          script: |
            const hasGCP = '${{ needs.check-secrets.outputs.has-gcp }}' === 'true';
            const shortsUrl = '${{ needs.deploy-backend.outputs.shorts-url }}';
            const marketDataUrl = '${{ needs.deploy-backend.outputs.market-data-url }}';
            const vercelUrl = '${{ needs.deploy-vercel-preview.outputs.preview-url }}';

            let body = '## ðŸš€ Preview Deployment\n\n';

            body += '### Frontend\n\n';
            if (vercelUrl) {
              body += `âœ… **Vercel Preview**: ${vercelUrl}\n\n`;
            } else {
              body += 'âš ï¸ **Vercel** will automatically deploy via GitHub integration\n';
              body += 'Check the Vercel bot comment below for the preview URL\n\n';
            }

            body += '### Backend Services\n\n';
            if (hasGCP && shortsUrl) {
              body += `âœ… **Shorts API**: ${shortsUrl}\n`;
              body += `âœ… **Market Data API**: ${marketDataUrl}\n\n`;
              body += `*Connected to Vercel preview automatically*\n`;
            } else {
              body += `âš ï¸ **Backend services not deployed** - GCP secrets not configured\n\n`;
              body += '### âš™ï¸ Configuration Needed\n\n';
              body += 'To enable PR-specific backend deployments, configure these secrets:\n\n';
              body += '- `GCP_PROJECT_ID`\n- `WIP_PROVIDER`\n- `SA_EMAIL`\n- `DATABASE_URL`\n\n';
            }

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && comment.body.includes('Preview Deployment')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }

  test-unit:
    runs-on: ubuntu-latest

    services:
      docker:
        image: docker:24-dind
        options: --privileged

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: web/package-lock.json

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: services/go.sum

      - name: Install frontend dependencies
        working-directory: web
        run: npm ci --legacy-peer-deps

      - name: Install backend dependencies
        working-directory: services
        run: go mod download

      - name: Run frontend unit tests
        working-directory: web
        run: npm test -- --watchAll=false --testPathIgnorePatterns=integration

      - name: Setup Docker for testcontainers
        run: |
          docker info
          docker ps

      - name: Run backend unit tests
        working-directory: services
        env:
          DOCKER_HOST: unix:///var/run/docker.sock
          TESTCONTAINERS_RYUK_DISABLED: true
        run: |
          go test ./... -v -cover -timeout 15m
        continue-on-error: true

      - name: Upload frontend coverage
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: frontend-coverage
          path: web/coverage/
          retention-days: 7

      - name: Upload backend coverage
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: backend-coverage
          path: services/coverage.out
          retention-days: 7

  test-integration:
    needs: [check-secrets, deploy-backend]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: |
            services/go.sum
            test/integration/go.sum

      - name: Install test dependencies
        run: |
          cd test/integration
          go mod download

      - name: Verify Docker is available
        run: |
          docker version
          docker info

      - name: Run integration tests (testcontainers)
        if: needs.check-secrets.outputs.has-gcp == 'true' && needs.deploy-backend.outputs.shorts-url != ''
        env:
          BACKEND_URL: ${{ needs.deploy-backend.outputs.shorts-url }}
        run: |
          echo "ðŸ§ª Running integration tests against deployed preview..."
          echo "Backend URL: $BACKEND_URL"
          echo ""

          cd services
          make test-integration-ci
        continue-on-error: true

      - name: Run integration tests (local with testcontainers)
        if: needs.check-secrets.outputs.has-gcp != 'true' || needs.deploy-backend.outputs.shorts-url == ''
        run: |
          echo "ðŸ§ª Running integration tests with local testcontainers..."
          echo ""

          cd services
          make test-integration-local
        continue-on-error: true

  test-summary:
    needs: [test-unit, test-integration, deploy-vercel-preview]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Create test summary
        uses: actions/github-script@v7
        with:
          script: |
            const results = {
              unit: '${{ needs.test-unit.result }}',
              integration: '${{ needs.test-integration.result }}',
              'vercel-deploy': '${{ needs.deploy-vercel-preview.result }}'
            };

            let summary = '## ðŸ§ª Test Results Summary\n\n';

            for (const [test, result] of Object.entries(results)) {
              const emoji = result === 'success' ? 'âœ…' : result === 'failure' ? 'âŒ' : 'â­ï¸';
              summary += `${emoji} **${test.charAt(0).toUpperCase() + test.slice(1)} Tests**: ${result}\n`;
            }

            if (context.eventName === 'pull_request') {
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const botComment = comments.find(comment => 
                comment.user.type === 'Bot' && comment.body.includes('Test Results Summary')
              );
              
              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: summary
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: summary
                });
              }
            }

            await core.summary
              .addRaw(summary)
              .write();
