name: Preview and Test

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [main, develop]
  workflow_dispatch:

env:
  NODE_VERSION: "20"
  GO_VERSION: "1.23"
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: australia-southeast2
  ARTIFACT_REGISTRY: australia-southeast2-docker.pkg.dev
  PR_NUMBER: ${{ github.event.pull_request.number || 'manual' }}

permissions:
  contents: read
  id-token: write
  pull-requests: write
  deployments: write

jobs:
  check-secrets:
    runs-on: ubuntu-latest
    outputs:
      has-gcp: ${{ steps.check.outputs.has-gcp }}
    steps:
      - name: Check required secrets
        id: check
        run: |
          HAS_GCP="false"

          if [ -n "${{ secrets.GCP_PROJECT_ID }}" ] && [ -n "${{ secrets.WIP_PROVIDER }}" ] && [ -n "${{ secrets.SA_EMAIL }}" ]; then
            HAS_GCP="true"
          fi

          echo "has-gcp=$HAS_GCP" >> $GITHUB_OUTPUT

          echo "GCP secrets configured: $HAS_GCP"
          echo "Note: Vercel will automatically deploy via GitHub integration"

  deploy-backend:
    needs: check-secrets
    if: needs.check-secrets.outputs.has-gcp == 'true'
    runs-on: ubuntu-latest
    outputs:
      shorts-url: ${{ steps.deploy-services.outputs.shorts-url }}
      market-data-url: ${{ steps.deploy-services.outputs.market-data-url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: web/package-lock.json

      - name: Setup Go
        if: needs.check-secrets.outputs.has-gcp == 'true'
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: services/go.sum

      - name: Authenticate to Google Cloud
        if: needs.check-secrets.outputs.has-gcp == 'true'
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIP_PROVIDER }}
          service_account: ${{ secrets.SA_EMAIL }}

      - name: Set up Cloud SDK
        if: needs.check-secrets.outputs.has-gcp == 'true'
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        if: needs.check-secrets.outputs.has-gcp == 'true'
        run: |
          gcloud auth configure-docker ${{ env.ARTIFACT_REGISTRY }}

      - name: Build and push Docker images
        if: needs.check-secrets.outputs.has-gcp == 'true'
        run: |
          cd services

          # Build and push Shorts Service
          docker build -f shorts/Dockerfile -t ${{ env.ARTIFACT_REGISTRY }}/${{ env.GCP_PROJECT_ID }}/shorted/shorts:pr-${{ env.PR_NUMBER }} .
          docker push ${{ env.ARTIFACT_REGISTRY }}/${{ env.GCP_PROJECT_ID }}/shorted/shorts:pr-${{ env.PR_NUMBER }}

          # Build and push Market Data Service
          docker build -f market-data/Dockerfile -t ${{ env.ARTIFACT_REGISTRY }}/${{ env.GCP_PROJECT_ID }}/shorted/market-data:pr-${{ env.PR_NUMBER }} .
          docker push ${{ env.ARTIFACT_REGISTRY }}/${{ env.GCP_PROJECT_ID }}/shorted/market-data:pr-${{ env.PR_NUMBER }}

      - name: Deploy preview backend services to Cloud Run
        if: needs.check-secrets.outputs.has-gcp == 'true'
        id: deploy-services
        run: |
          # Deploy Shorts Service
          gcloud run deploy shorts-service-pr-${{ env.PR_NUMBER }} \
            --image ${{ env.ARTIFACT_REGISTRY }}/${{ env.GCP_PROJECT_ID }}/shorted/shorts:pr-${{ env.PR_NUMBER }} \
            --region ${{ env.GCP_REGION }} \
            --platform managed \
            --allow-unauthenticated \
            --port 9091 \
            --memory 256Mi \
            --cpu 1 \
            --min-instances 0 \
            --max-instances 2 \
            --set-env-vars="DATABASE_URL=${{ secrets.DATABASE_URL }}" \
            --set-env-vars="ENVIRONMENT=preview" \
            --labels="pr=${{ env.PR_NUMBER }},type=preview" \
            --tag pr-${{ env.PR_NUMBER }}

          # Deploy Market Data Service
          gcloud run deploy market-data-service-pr-${{ env.PR_NUMBER }} \
            --image ${{ env.ARTIFACT_REGISTRY }}/${{ env.GCP_PROJECT_ID }}/shorted/market-data:pr-${{ env.PR_NUMBER }} \
            --region ${{ env.GCP_REGION }} \
            --platform managed \
            --allow-unauthenticated \
            --port 8090 \
            --memory 256Mi \
            --cpu 1 \
            --min-instances 0 \
            --max-instances 2 \
            --set-env-vars="DATABASE_URL=${{ secrets.DATABASE_URL }}" \
            --set-env-vars="ENVIRONMENT=preview" \
            --labels="pr=${{ env.PR_NUMBER }},type=preview" \
            --tag pr-${{ env.PR_NUMBER }}

          # Get service URLs
          SHORTS_URL=$(gcloud run services describe shorts-service-pr-${{ env.PR_NUMBER }} \
            --region ${{ env.GCP_REGION }} --format 'value(status.url)')
          MARKET_DATA_URL=$(gcloud run services describe market-data-service-pr-${{ env.PR_NUMBER }} \
            --region ${{ env.GCP_REGION }} --format 'value(status.url)')

          echo "shorts-url=$SHORTS_URL" >> $GITHUB_OUTPUT
          echo "market-data-url=$MARKET_DATA_URL" >> $GITHUB_OUTPUT
          echo "Shorts Service: $SHORTS_URL"
          echo "Market Data Service: $MARKET_DATA_URL"

      - name: Summary
        run: |
          echo "âœ… Backend services deployed successfully for PR #${{ env.PR_NUMBER }}"
          echo "Shorts Service: ${{ steps.deploy-services.outputs.shorts-url }}"
          echo "Market Data Service: ${{ steps.deploy-services.outputs.market-data-url }}"
          echo ""
          echo "Note: Vercel will automatically deploy the frontend via GitHub integration"

  comment-deployment:
    needs: [check-secrets, deploy-backend]
    runs-on: ubuntu-latest
    if: always() && github.event_name == 'pull_request'
    steps:
      - name: Comment PR with deployment info
        uses: actions/github-script@v7
        with:
          script: |
            const hasGCP = '${{ needs.check-secrets.outputs.has-gcp }}' === 'true';
            const shortsUrl = '${{ needs.deploy-backend.outputs.shorts-url }}';
            const marketDataUrl = '${{ needs.deploy-backend.outputs.market-data-url }}';

            let body = '## ðŸš€ Preview Deployment\n\n';

            body += '### Frontend\n\n';
            body += 'âœ… **Vercel** will automatically deploy the frontend via GitHub integration\n';
            body += 'Check the Vercel bot comment below for the preview URL\n\n';

            body += '### Backend Services\n\n';
            if (hasGCP && shortsUrl) {
              body += `âœ… **Shorts API** (PR-specific): ${shortsUrl}\n`;
              body += `âœ… **Market Data API** (PR-specific): ${marketDataUrl}\n\n`;
              body += `*PR-specific backend services deployed to Cloud Run*\n`;
            } else {
              body += `âš ï¸ **Backend services not deployed** - GCP secrets not configured\n\n`;
              body += '### âš™ï¸ Configuration Needed\n\n';
              body += 'To enable PR-specific backend deployments, configure these secrets:\n\n';
              body += '- `GCP_PROJECT_ID`\n- `WIP_PROVIDER`\n- `SA_EMAIL`\n- `DATABASE_URL`\n\n';
              body += 'See [Preview Deployment Guide](../docs/PREVIEW_DEPLOYMENTS.md) for setup instructions.\n';
            }

            // Find and update or create comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && comment.body.includes('Preview Deployment')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }

  test-unit:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: web/package-lock.json

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: services/go.sum

      - name: Install frontend dependencies
        working-directory: web
        run: npm ci --legacy-peer-deps

      - name: Install backend dependencies
        working-directory: services
        run: go mod download

      - name: Run frontend unit tests
        working-directory: web
        run: npm test -- --coverage --watchAll=false --testPathIgnorePatterns=integration
        continue-on-error: true # Allow tests to fail for now

      - name: Run backend unit tests
        working-directory: services
        run: go test ./... -v -cover
        continue-on-error: true # Allow tests to fail for now

      - name: Upload frontend coverage
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: frontend-coverage
          path: web/coverage/
          retention-days: 7

      - name: Upload backend coverage
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: backend-coverage
          path: services/coverage.out
          retention-days: 7

  test-integration:
    needs: [check-secrets, deploy-backend]
    runs-on: ubuntu-latest
    if: always()

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: shorted_test
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: web/package-lock.json

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: services/go.sum

      - name: Install dependencies
        run: |
          cd web && npm ci --legacy-peer-deps
          cd ../services && go mod download

      - name: Setup test database
        env:
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432
          POSTGRES_DB: shorted_test
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        run: |
          # Wait for PostgreSQL
          for i in {1..30}; do
            if pg_isready -h localhost -p 5432 -U test_user; then
              echo "PostgreSQL is ready"
              break
            fi
            echo "Waiting for PostgreSQL... attempt $i/30"
            sleep 2
          done

          # Initialize schema
          if [ -f analysis/sql/init-db.sql ]; then
            PGPASSWORD=test_password psql -h localhost -p 5432 -U test_user -d shorted_test -f analysis/sql/init-db.sql || true
          fi

      - name: Run integration tests against preview
        env:
          SHORTS_URL: ${{ needs.deploy-backend.outputs.shorts-url }}
          MARKET_DATA_URL: ${{ needs.deploy-backend.outputs.market-data-url }}
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/shorted_test
        run: |
          echo "Testing against backend services:"
          echo "Shorts URL: $SHORTS_URL"
          echo "Market Data URL: $MARKET_DATA_URL"

          # Run integration tests
          cd test/integration 2>/dev/null || cd services
          go test ./... -v -tags=integration || true
        continue-on-error: true

  test-e2e:
    needs: [check-secrets, deploy-backend]
    runs-on: ubuntu-latest
    if: needs.check-secrets.outputs.has-gcp == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: services/go.sum

      - name: Install dependencies
        working-directory: services
        run: go mod download

      - name: Test deployed backend services
        env:
          SHORTS_SERVICE_URL: ${{ needs.deploy-backend.outputs.shorts-url }}
          MARKET_DATA_SERVICE_URL: ${{ needs.deploy-backend.outputs.market-data-url }}
        run: |
          echo "ðŸ§ª Testing deployed preview backend services"
          echo "Shorts API: $SHORTS_SERVICE_URL"
          echo "Market Data API: $MARKET_DATA_SERVICE_URL"
          echo ""

          # Test Shorts Service Health
          echo "Testing Shorts Service health..."
          SHORTS_HEALTH=$(curl -f -s "$SHORTS_SERVICE_URL/health" || echo "FAILED")
          if [ "$SHORTS_HEALTH" != "FAILED" ]; then
            echo "âœ… Shorts service is healthy: $SHORTS_HEALTH"
          else
            echo "âŒ Shorts service health check failed"
            exit 1
          fi

          # Test Market Data Service Health
          echo ""
          echo "Testing Market Data Service health..."
          MARKET_HEALTH=$(curl -f -s "$MARKET_DATA_SERVICE_URL/health" || echo "FAILED")
          if [ "$MARKET_HEALTH" != "FAILED" ]; then
            echo "âœ… Market Data service is healthy: $MARKET_HEALTH"
          else
            echo "âŒ Market Data service health check failed"
            exit 1
          fi

          # Test actual API endpoints (Connect RPC smoke tests)
          echo ""
          echo "Running API smoke tests..."
          
          # Test GetTopShorts endpoint with Connect RPC format
          echo "Testing GetTopShorts API..."
          RESPONSE=$(curl -s -X POST "$SHORTS_SERVICE_URL/shorts.v1alpha1.ShortedStocksService/GetTopShorts" \
            -H "Content-Type: application/json" \
            -d '{"period":"1M","limit":5,"offset":0}')
          
          if echo "$RESPONSE" | grep -q "timeSeries\|time_series"; then
            echo "âœ… GetTopShorts API responding with data"
          else
            echo "âš ï¸ GetTopShorts API response: $RESPONSE"
            echo "Note: May need data in database or different format"
          fi
          
          # Test GetStock endpoint
          echo "Testing GetStock API..."
          if curl -f -s -X POST "$SHORTS_SERVICE_URL/shorts.v1alpha1.ShortedStocksService/GetStock" \
            -H "Content-Type: application/json" \
            -d '{"productCode":"CBA"}' > /dev/null 2>&1; then
            echo "âœ… GetStock API responding"
          else
            echo "âš ï¸ GetStock API might need data (expected for empty database)"
          fi
          
          echo ""
          echo "âœ… All deployed services are accessible and responding!"
        continue-on-error: false

  test-summary:
    needs: [test-unit, test-integration, test-e2e]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Create test summary
        uses: actions/github-script@v7
        with:
          script: |
            const results = {
              unit: '${{ needs.test-unit.result }}',
              integration: '${{ needs.test-integration.result }}',
              e2e: '${{ needs.test-e2e.result }}'
            };

            let summary = '## ðŸ§ª Test Results Summary\n\n';

            for (const [test, result] of Object.entries(results)) {
              const emoji = result === 'success' ? 'âœ…' : result === 'failure' ? 'âŒ' : 'â­ï¸';
              summary += `${emoji} **${test.charAt(0).toUpperCase() + test.slice(1)} Tests**: ${result}\n`;
            }

            // Add to PR comment if it's a PR
            if (context.eventName === 'pull_request') {
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const botComment = comments.find(comment => 
                comment.user.type === 'Bot' && comment.body.includes('Test Results Summary')
              );
              
              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: summary
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: summary
                });
              }
            }

            // Add to job summary
            await core.summary
              .addRaw(summary)
              .write();
